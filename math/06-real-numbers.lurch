
            <div id="loadlink">
                <p><a>Open this file in the Lurch web app</a></p>
                <script language="javascript">
                    const link = document.querySelector( '#loadlink > p > a' )
                    const thisURL = encodeURIComponent( window.location.href )
                    link?.setAttribute( 'href', 'http://localhost:64157/app/?load=' + thisURL )
                </script>
            </div>
        
            <div id="metadata" style="display: none;"><div data-category="main" data-key="header" data-value-type="html"><div class="lurch-atom" contenteditable="false" data-metadata_type="&quot;dependency&quot;" data-metadata_description="&quot;none&quot;" data-metadata_filename="&quot;../math/real-numbers-rules.lurch&quot;" data-metadata_source="&quot;the web&quot;" data-metadata_auto-refresh="true" style="border: 1px solid gray; padding: 0px 1em;"><div class="lurch-atom-metadata" style="display: none;"><div data-key="content">
            <div id="loadlink">
                <p><a>Open this file in the Lurch web app</a></p>
                
            </div>
        
            <div id="metadata" style="display: none;"><div data-category="main" data-key="header" data-value-type="html"><div class="lurch-atom" contenteditable="false" data-metadata_type="&quot;dependency&quot;" data-metadata_description="&quot;none&quot;" data-metadata_filename="&quot;../math/predicate-logic-rules.lurch&quot;" data-metadata_source="&quot;the web&quot;" data-metadata_auto-refresh="true" style="border: 1px solid gray; padding: 0px 1em;"><div class="lurch-atom-metadata" style="display: none;"><div data-key="content">
            <div id="loadlink">
                <p><a>Open this file in the Lurch web app</a></p>
                
            </div>
        
            <div id="metadata" style="display: none;"><div data-category="main" data-key="header" data-value-type="html"><div class="lurch-atom" contenteditable="false" data-metadata_type="&quot;dependency&quot;" data-metadata_description="&quot;none&quot;" data-metadata_filename="&quot;../math/propositional-logic-rules.lurch&quot;" data-metadata_source="&quot;the web&quot;" data-metadata_auto-refresh="true" style="border: 1px solid gray; padding: 0px 1em;"><div class="lurch-atom-metadata" style="display: none;"><div data-key="content">
            <div id="loadlink">
                <p><a>Open this file in the Lurch web app</a></p>
                
            </div>
        
            <div id="metadata" style="display: none;"><div data-category="settings" data-key="shell style" data-value-type="json">"boxed"</div></div>
            <div id="document"><h1>Rules for Propositional Logic</h1>
<p>There are many ways to express the rules for propositional logic, but here is one way. We don't use these rules for any proofs in this document; it's just the set of rules. See the table of contents for this tutorial site for examples of how to import and use these rules.</p>
<p><span style="text-decoration: underline;"><strong>Tip:</strong></span> Try viewing the document below in two different modes, by clicking the Document menu, then choosing "Show/hide meaning." One view shows every expression and environment clearly designated by colors and borders, while the other view keeps everything minimalist and black-and-white. You can switch between these views easily with the keyboard shortcut Alt+0. Which do you prefer?</p>
<h2>Operators</h2>
<p>In Lurch, we must declare up front which symbols are the operators and other constants that we're using, so that they are not later treated as variables:&nbsp;<span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;Declare and, or, not, implies, iff&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">Declare and, or, </span><span class="ML__ams">¬</span><span class="ML__text">, </span><span class="ML__cmr">⇒</span><span class="ML__text">, and </span><span class="ML__cmr">⇔</span></span></span></span></span>.</p>
<h2>Rules for conjunction</h2>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Conjunction introduction:</p>
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;Assume A&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">Assume </span><span class="ML__mathit">A</span></span></span></span></span> and further <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;assume B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">assume </span><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span>. Then we can conclude <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;A and B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">A</span><span class="ML__text"> and </span><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span>.</p>
</div>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Conjunction elimination:</p>
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;Assume A and B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">Assume </span><span class="ML__mathit">A</span><span class="ML__text"> and </span><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span>. Then we can conclude <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;A&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">A</span></span></span></span></span>, or we could instead conclude <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span>, or both.</p>
</div>
<h2>Rules for disjunction</h2>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Disjunction introduction:</p>
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;Assume A&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">Assume </span><span class="ML__mathit">A</span></span></span></span></span>. Then we can conclude <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;A or B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">A</span><span class="ML__text"> or </span><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span>, and we can also conclude <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;B or A&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit" style="margin-right: 0.06em;">B</span><span class="ML__text"> or </span><span class="ML__mathit">A</span></span></span></span></span>.</p>
</div>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Disjunction elimination:</p>
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;Assume A or B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">Assume </span><span class="ML__mathit">A</span><span class="ML__text"> or </span><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span>. Then we can proceed in one of two ways.</p>
<div class="lurch-atom" data-metadata_type="&quot;subproof&quot;" data-shell_title="">
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;If not A&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">If not </span><span class="ML__mathit">A</span></span></span></span></span> is true, then we can conclude that <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span> must be true.</p>
</div>
<div class="lurch-atom" data-metadata_type="&quot;subproof&quot;" data-shell_title="">
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;If not B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">If not </span><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span> is true, then we can conclude that <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;A&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">A</span></span></span></span></span> must be true.</p>
</div>
</div>
<h2>Rules for conditional</h2>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Conditional introduction:</p>
<div class="lurch-atom" data-metadata_type="&quot;premise&quot;" data-shell_title="">
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;Assume A&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">Assume </span><span class="ML__mathit">A</span></span></span></span></span> at the start of a subproof.</p>
<p>Do whatever work is necessary in that subproof to conclude <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span>.</p>
</div>
<p>Then outside the subproof, you can conclude&nbsp;<span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;A implies B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">A</span><span class="ML__cmr">⇒</span><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span>.</p>
</div>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Conditional elimination:</p>
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;Assume A&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">Assume </span><span class="ML__mathit">A</span></span></span></span></span> and further assume <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;A implies B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">A</span><span class="ML__cmr">⇒</span><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span>. Then we can conclude <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span>.</p>
</div>
<h2>Rules for negation</h2>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Negation introduction:</p>
<div class="lurch-atom" data-metadata_type="&quot;premise&quot;" data-shell_title="">
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;Assume A&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">Assume </span><span class="ML__mathit">A</span></span></span></span></span> towards a contradiction at the start of a subproof.</p>
<p>Do whatever work is necessary in that subproof to conclude a contradiction, such as <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span> and <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;not B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">not </span><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span>.</p>
</div>
<p>Then outside the subproof, you can conclude <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;not A&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">not </span><span class="ML__mathit">A</span></span></span></span></span>.</p>
</div>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Negation elimination:</p>
<div class="lurch-atom" data-metadata_type="&quot;premise&quot;" data-shell_title="">
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;Assume not A&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">Assume not </span><span class="ML__mathit">A</span></span></span></span></span> towards a contradiction at the start of a subproof.</p>
<p>Do whatever work is necessary in that subproof to conclude a contradiction, such as <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span> and <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;not B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">not </span><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span>.</p>
</div>
<p>Then outside the subproof, you can conclude <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;A&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">A</span></span></span></span></span>.</p>
</div>
<h2>Rules for biconditional</h2>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Biconditional introduction:</p>
<div class="lurch-atom" data-metadata_type="&quot;premise&quot;" data-shell_title="">
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;Assume A&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">Assume </span><span class="ML__mathit">A</span></span></span></span></span> at the start of a subproof.</p>
<p>Do whatever work is necessary in that subproof to conclude <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span>.</p>
</div>
<div class="lurch-atom" data-metadata_type="&quot;premise&quot;" data-shell_title="">
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;Assume B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">Assume </span><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span> at the start of a second subproof.</p>
<p>Do whatever work is necessary in that subproof to conclude <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;A&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">A</span></span></span></span></span>.</p>
</div>
<p>Then outside of both subproofs, you can conclude <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;A iff B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">A</span><span class="ML__cmr">⇔</span><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span>.</p>
</div>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Biconditional elimination:</p>
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;Assume A iff B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">Assume </span><span class="ML__mathit">A</span><span class="ML__cmr">⇔</span><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span>. Then we can proceed in one of two ways.</p>
<div class="lurch-atom" data-metadata_type="&quot;subproof&quot;" data-shell_title="">
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;If A&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">If </span><span class="ML__mathit">A</span></span></span></span></span> is true, from it, we can conclude <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span>.</p>
</div>
<div class="lurch-atom" data-metadata_type="&quot;subproof&quot;" data-shell_title="">
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;If B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">If </span><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span> is true, from it, we can conclude <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;A&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">A</span></span></span></span></span>.</p>
</div>
</div>
<p>&nbsp;</p></div>
        </div></div><div class="lurch-atom-body"><table><colgroup><col><col></colgroup><tbody><tr><td colspan="2"><b>Imported dependency document</b></td></tr><tr><td>Description:</td><td><tt>none</tt></td></tr><tr><td>Filename:</td><td><tt>../math/propositional-logic-rules.lurch</tt></td></tr><tr><td>Source:</td><td>the web</td></tr><tr><td>Auto-refresh:</td><td>yes</td></tr></tbody></table></div></div></div></div>
            <div id="document"><h1>Rules for Predicate Logic</h1>
<p>This document imports the rules for propositional logic, and augments them with the new rules below.</p>
<h2>Rules for universal quantification</h2>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Universal introduction:</p>
<div class="lurch-atom" data-metadata_type="&quot;premise&quot;" data-shell_title="">
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;Let x&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">Let </span><span class="ML__mathit">x</span></span></span></span></span> be arbitrary inside a new subproof, like this one. Then do whatever work is necessary to prove some conclusion <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;@P(x)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__cal" style="margin-right: 0.09em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">x</span><span class="ML__small-delim ML__close">)</span></span></span></span></span></span> about <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expositorymath&quot;" data-metadata_latex="&quot;x&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">x</span></span></span></span></span>.</p>
</div>
<p>Based on that subproof, and outside of that subproof, you can then conclude <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;forall x. @P(x)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__cmr">∀</span><span class="ML__mathit">x</span><span class="ML__cmr">.</span><span class="ML__cal" style="margin-right: 0.09em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">x</span><span class="ML__small-delim ML__close">)</span></span></span></span></span></span>.</p>
</div>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Universal elimination:</p>
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;If forall x.@P(x)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">If </span><span class="ML__cmr">∀</span><span class="ML__mathit">x</span><span class="ML__cmr">.</span><span class="ML__cal" style="margin-right: 0.09em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">x</span><span class="ML__small-delim ML__close">)</span></span></span></span></span></span> is true, then we can apply it to any particular target, as in <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;@P(t)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__cal" style="margin-right: 0.09em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.61508em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">t</span><span class="ML__small-delim ML__close">)</span></span></span></span></span></span>.</p>
</div>
<h2>Rules for existential quantification</h2>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Existential introduction:</p>
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;If @P(t)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">If </span><span class="ML__cal" style="margin-right: 0.09em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.61508em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">t</span><span class="ML__small-delim ML__close">)</span></span></span></span></span></span> holds for any particular thing <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expositorymath&quot;" data-metadata_latex="&quot;t&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">t</span></span></span></span></span>, then we can say <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;exists x.@P(x)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__cmr">∃</span><span class="ML__mathit">x</span><span class="ML__cmr">.</span><span class="ML__cal" style="margin-right: 0.09em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">x</span><span class="ML__small-delim ML__close">)</span></span></span></span></span></span>.</p>
</div>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Existential elimination:</p>
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;If exists x.@P(x)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">If </span><span class="ML__cmr">∃</span><span class="ML__mathit">x</span><span class="ML__cmr">.</span><span class="ML__cal" style="margin-right: 0.09em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">x</span><span class="ML__small-delim ML__close">)</span></span></span></span></span></span>, then we can choose a name for the object that we know exists, allowing us to discuss the object in our proof, stating <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;@P(c) for some c&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__cal" style="margin-right: 0.09em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">c</span><span class="ML__small-delim ML__close">)</span></span><span class="ML__text"> for some </span><span class="ML__mathit">c</span></span></span></span></span>.&nbsp; We choose the name <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expositorymath&quot;" data-metadata_latex="&quot;c&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">c</span></span></span></span></span> because some refer to the symbol as a "constant."</p>
</div>
<h2>Rules for equality</h2>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Equality introduction:</p>
<p>You can write <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;x=x&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">x</span><span class="ML__cmr">=</span><span class="ML__mathit">x</span></span></span></span></span> for any term <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expositorymath&quot;" data-metadata_latex="&quot;x&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">x</span></span></span></span></span>.</p>
</div>
<p>The following rule is so important for proving chains of equalities that we have to flag it for Lurch as our version of the <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;SubsRule&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">Substitution </span></span></span></span></span>rule. In a future version of Lurch, when we have streamlined our algorithms, we hope that extra label will not be required.</p>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Equality elimination, which can operate in two directions:</p>
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;If a=b&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">If </span><span class="ML__mathit">a</span><span class="ML__cmr">=</span><span class="ML__mathit">b</span></span></span></span></span> then we can use that equation for substitution.</p>
<div class="lurch-atom" data-metadata_type="&quot;subproof&quot;" data-shell_title="">
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;If @P(a)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">If </span><span class="ML__cal" style="margin-right: 0.09em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">a</span><span class="ML__small-delim ML__close">)</span></span></span></span></span></span> for any statement <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expositorymath&quot;" data-metadata_latex="&quot;\\mathcal{P}&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__cal" style="margin-right: 0.09em;">P</span></span></span></span></span>, then we can conclude <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;@P(b)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__cal" style="margin-right: 0.09em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.69444em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">b</span><span class="ML__small-delim ML__close">)</span></span></span></span></span></span> for the same statement <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expositorymath&quot;" data-metadata_latex="&quot;\\mathcal{P}&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__cal" style="margin-right: 0.09em;">P</span></span></span></span></span>.</p>
</div>
<div class="lurch-atom" data-metadata_type="&quot;subproof&quot;" data-shell_title="">
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;If @P(b)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">If </span><span class="ML__cal" style="margin-right: 0.09em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.69444em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">b</span><span class="ML__small-delim ML__close">)</span></span></span></span></span></span> for any statement <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expositorymath&quot;" data-metadata_latex="&quot;\\mathcal{P}&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__cal" style="margin-right: 0.09em;">P</span></span></span></span></span>, then we can conclude <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;@P(a)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__cal" style="margin-right: 0.09em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">a</span><span class="ML__small-delim ML__close">)</span></span></span></span></span></span> for the same statement <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expositorymath&quot;" data-metadata_latex="&quot;\\mathcal{P}&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__cal" style="margin-right: 0.09em;">P</span></span></span></span></span>.</p>
</div>
</div>
<p>Furthermore, if we want to permit users to write chains of equalities that receive special treatment for validation, we have to include the following rule that tells Lurch it can apply that special treatment.</p>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>The <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;EquationsRule&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">EquationsRule</span></span></span></span></span> is in force!</p>
</div>
<p>&nbsp;</p></div>
        </div></div><div class="lurch-atom-body"><table><colgroup><col><col></colgroup><tbody><tr><td colspan="2"><b>Imported dependency document</b></td></tr><tr><td>Description:</td><td><tt>none</tt></td></tr><tr><td>Filename:</td><td><tt>../math/predicate-logic-rules.lurch</tt></td></tr><tr><td>Source:</td><td>the web</td></tr><tr><td>Auto-refresh:</td><td>yes</td></tr></tbody></table></div></div></div></div>
            <div id="document"><h1>Axioms for the Real Numbers</h1>
<p>Although all the environments below are marked as "rules," we would normally call them "axioms" in mathematics. In Lurch, there is no distinction; both rules and axioms are facts you can rely on in later work.</p>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Associativity of addition: <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;(a+b)+c=a+(b+c)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__left-right" style="margin-top: -0.08333em; height: 0.77777em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">a</span><span class="ML__cmr">+</span><span class="ML__mathit">b</span><span class="ML__small-delim ML__close">)</span></span><span class="ML__cmr">+</span><span class="ML__mathit">c</span><span class="ML__cmr">=</span><span class="ML__mathit">a</span><span class="ML__cmr">+</span><span class="ML__left-right" style="margin-top: -0.08333em; height: 0.77777em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">b</span><span class="ML__cmr">+</span><span class="ML__mathit">c</span><span class="ML__small-delim ML__close">)</span></span></span></span></span></span></p>
</div>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Commutativity of addition: <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;a+b=b+a&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">a</span><span class="ML__cmr">+</span><span class="ML__mathit">b</span><span class="ML__cmr">=</span><span class="ML__mathit">b</span><span class="ML__cmr">+</span><span class="ML__mathit">a</span></span></span></span></span></p>
</div>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Additive identity: <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;a+0=a&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">a</span><span class="ML__cmr">+</span><span class="ML__cmr">0</span><span class="ML__cmr">=</span><span class="ML__mathit">a</span></span></span></span></span></p>
</div>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Additive inverse: <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;a+(-a)=0&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">a</span><span class="ML__cmr">+</span><span class="ML__left-right" style="margin-top: -0.08333em; height: 0.66666em;"><span class="ML__small-delim ML__open">(</span><span class="ML__cmr">−</span><span class="ML__mathit">a</span><span class="ML__small-delim ML__close">)</span></span><span class="ML__cmr">=</span><span class="ML__cmr">0</span></span></span></span></span></p>
</div>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Associativity of multiplication: <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;(a*b)*c=a*(b*c)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__left-right" style="margin-top: 0em; height: 0.69444em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">a</span><span class="ML__cmr">⋅</span><span class="ML__mathit">b</span><span class="ML__small-delim ML__close">)</span></span><span class="ML__cmr">⋅</span><span class="ML__mathit">c</span><span class="ML__cmr">=</span><span class="ML__mathit">a</span><span class="ML__cmr">⋅</span><span class="ML__left-right" style="margin-top: 0em; height: 0.69444em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">b</span><span class="ML__cmr">⋅</span><span class="ML__mathit">c</span><span class="ML__small-delim ML__close">)</span></span></span></span></span></span></p>
</div>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Commutativity of multiplication: <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;a*b=b*a&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">a</span><span class="ML__cmr">⋅</span><span class="ML__mathit">b</span><span class="ML__cmr">=</span><span class="ML__mathit">b</span><span class="ML__cmr">⋅</span><span class="ML__mathit">a</span></span></span></span></span></p>
</div>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Multiplicative identity: <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;a*1=a&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">a</span><span class="ML__cmr">⋅</span><span class="ML__cmr">1</span><span class="ML__cmr">=</span><span class="ML__mathit">a</span></span></span></span></span></p>
</div>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Multiplicative inverse: <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;If a neq 0&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">If </span><span class="ML__mathit">a</span><span class="ML__rlap"><span class="ML__inner"><span class="ML__cmr"></span></span></span><span class="ML__cmr">=</span><span class="ML__cmr">0</span></span></span></span></span> then <span class="lurch-atom atom-is-selected" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;a*(1/a)=1&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">a</span><span class="ML__cmr">⋅</span><span class="ML__left-right" style="margin-top: -0.686em; height: 1.8304399999999998em;"><span class="ML__open ML__delim-size2">(</span><span class="ML__mfrac"><span class="ML__vlist-t ML__vlist-t2"><span class="ML__vlist-r"><span class="ML__vlist" style="height: 1.15em;"><span class="ML__center" style="top: -2.31em;"><span style="height: 0.44em; display: inline-block;"><span class="ML__mathit">a</span></span></span><span class="ML__center" style="top: -3.5em;"><span style="height: 0.65em; display: inline-block;"><span class="ML__cmr">1</span></span></span></span><span class="ML__vlist-s">​</span></span></span></span><span class="ML__close ML__delim-size2">)</span></span><span class="ML__cmr">=</span><span class="ML__cmr">1</span></span></span></span></span></p>
</div>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Identities are different: <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;0 neq 1&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__cmr">0</span><span class="ML__rlap"><span class="ML__inner"><span class="ML__cmr"></span></span></span><span class="ML__cmr">=</span><span class="ML__cmr">1</span></span></span></span></span></p>
</div>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Distributivity: <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;a*(b+c)=a*b+a*c&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">a</span><span class="ML__cmr">⋅</span><span class="ML__left-right" style="margin-top: -0.08333em; height: 0.77777em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">b</span><span class="ML__cmr">+</span><span class="ML__mathit">c</span><span class="ML__small-delim ML__close">)</span></span><span class="ML__cmr">=</span><span class="ML__mathit">a</span><span class="ML__cmr">⋅</span><span class="ML__mathit">b</span><span class="ML__cmr">+</span><span class="ML__mathit">a</span><span class="ML__cmr">⋅</span><span class="ML__mathit">c</span></span></span></span></span></p>
</div>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Archimedean property: <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;a leq b or b leq a&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">a</span><span class="ML__cmr">≤</span><span class="ML__mathit">b</span><span class="ML__text"> or </span><span class="ML__mathit">b</span><span class="ML__cmr">≤</span><span class="ML__mathit">a</span></span></span></span></span></p>
</div>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Linear order: <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;If a leq b&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">If </span><span class="ML__mathit">a</span><span class="ML__cmr">≤</span><span class="ML__mathit">b</span></span></span></span></span> and <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;if b leq a&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">if </span><span class="ML__mathit">b</span><span class="ML__cmr">≤</span><span class="ML__mathit">a</span></span></span></span></span> then <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;a = b&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">a</span><span class="ML__cmr">=</span><span class="ML__mathit">b</span></span></span></span></span></p>
</div>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Transitivity: <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;If a leq b&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">If </span><span class="ML__mathit">a</span><span class="ML__cmr">≤</span><span class="ML__mathit">b</span></span></span></span></span> and <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;if b leq c&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">if </span><span class="ML__mathit">b</span><span class="ML__cmr">≤</span><span class="ML__mathit">c</span></span></span></span></span> then <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;a leq c&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">a</span><span class="ML__cmr">≤</span><span class="ML__mathit">c</span></span></span></span></span></p>
</div>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Addition preserves order: <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;If a leq b&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">If </span><span class="ML__mathit">a</span><span class="ML__cmr">≤</span><span class="ML__mathit">b</span></span></span></span></span> then <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;a+c leq b+c&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">a</span><span class="ML__cmr">+</span><span class="ML__mathit">c</span><span class="ML__cmr">≤</span><span class="ML__mathit">b</span><span class="ML__cmr">+</span><span class="ML__mathit">c</span></span></span></span></span></p>
</div>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Multiplication preserves order: <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;If a leq b&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">If </span><span class="ML__mathit">a</span><span class="ML__cmr">≤</span><span class="ML__mathit">b</span></span></span></span></span> and <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;if 0 leq c&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">if </span><span class="ML__cmr">0</span><span class="ML__cmr">≤</span><span class="ML__mathit">c</span></span></span></span></span> then <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;a*c leq b*c&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">a</span><span class="ML__cmr">⋅</span><span class="ML__mathit">c</span><span class="ML__cmr">≤</span><span class="ML__mathit">b</span><span class="ML__cmr">⋅</span><span class="ML__mathit">c</span></span></span></span></span></p>
</div>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Definition of less than:</p>
<div class="lurch-atom" data-metadata_type="&quot;subproof&quot;" data-shell_title="">
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;If a < b&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">If </span><span class="ML__mathit">a</span><span class="ML__cmr">&lt;</span><span class="ML__mathit">b</span></span></span></span></span> then <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;a leq b&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">a</span><span class="ML__cmr">≤</span><span class="ML__mathit">b</span></span></span></span></span> and <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;a neq b&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">a</span><span class="ML__rlap"><span class="ML__inner"><span class="ML__cmr"></span></span></span><span class="ML__cmr">=</span><span class="ML__mathit">b</span></span></span></span></span></p>
</div>
<div class="lurch-atom" data-metadata_type="&quot;subproof&quot;" data-shell_title="">
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;If a leq b&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">If </span><span class="ML__mathit">a</span><span class="ML__cmr">≤</span><span class="ML__mathit">b</span></span></span></span></span> and <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;if a neq b&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">if </span><span class="ML__mathit">a</span><span class="ML__rlap"><span class="ML__inner"><span class="ML__cmr"></span></span></span><span class="ML__cmr">=</span><span class="ML__mathit">b</span></span></span></span></span> then <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;a < b&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">a</span><span class="ML__cmr">&lt;</span><span class="ML__mathit">b</span></span></span></span></span></p>
</div>
</div></div>
        </div></div><div class="lurch-atom-body"><table><colgroup><col><col></colgroup><tbody><tr><td colspan="2"><b>Imported dependency document</b></td></tr><tr><td>Description:</td><td><tt>none</tt></td></tr><tr><td>Filename:</td><td><tt>../math/real-numbers-rules.lurch</tt></td></tr><tr><td>Source:</td><td>the web</td></tr><tr><td>Auto-refresh:</td><td>yes</td></tr></tbody></table></div></div></div><div data-category="settings" data-key="shell style" data-value-type="json">"boxed"</div></div>
            <div id="document"><h1>Some Mathematical Proofs</h1>
<h2>Yes, actual mathematical content!</h2>
<p>Perhaps that's not a fair title, since logic is a part of mathematics, but most of the time when we speak of mathematics, we're thinking about applying logic (informally) to numbers, shapes, sets, that sort of thing. This is the first document in this tutorial series in which we will talk about actual numbers!</p>
<p>I've imported several axioms about the real numbers, and you can view them in the usual way (Document menu, Hide/show rules). Let's try out doing some simple proofs in an informal style, to see how Lurch handles an axiomatic approach to the real numbers.</p>
<p>Keep in mind that we are doing this axiomatically, as you can tell by the very basic rules we've imported. Lurch also supports using a computer algebra system to make algebraic arguments&nbsp;<em>much</em> simpler, but we are not covering that in this tutorial.</p>
<h2>Just getting off the ground with real numbers</h2>
<p>The axioms we've imported assume that the entire domain of discourse is the real numbers, so we will not be writing things like "if <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expositorymath&quot;" data-metadata_latex="&quot;x \\in \\mathbb{R}&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">x</span><span class="ML__cmr">&isin;</span><span class="ML__bb">R</span></span></span></span></span>" and so forth. Everything is a real number.</p>
<div class="lurch-atom" title="Good work!" data-metadata_type="&quot;theorem&quot;" data-shell_title="Theorem:" data-validation_result="valid">
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;-0=0&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__cmr">&minus;0</span><span class="ML__cmr">=</span><span class="ML__cmr">0</span></span></span></span><span class="lurch-atom-suffix"><span class="feedback-marker-valid">&nbsp;</span></span></span></p>
</div>
<div class="lurch-atom" title="Good work!" data-metadata_type="&quot;proof&quot;" data-shell_title="Proof:" data-validation_result="valid">
<p>The additive inverse axiom gives us <span class="lurch-atom" title="Good work!" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;0+(-0)=0&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__cmr">0</span><span class="ML__cmr">+</span><span class="ML__left-right" style="margin-top: -0.08333em; height: 0.72777em;"><span class="ML__small-delim ML__open">(</span><span class="ML__cmr">&minus;0</span><span class="ML__small-delim ML__close">)</span></span><span class="ML__cmr">=</span><span class="ML__cmr">0</span></span></span></span><span class="lurch-atom-suffix"><span class="feedback-marker-valid">&nbsp;</span></span></span>, and the additive identity axiom gives us <span class="lurch-atom" title="Good work!" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;-0+0=-0&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__cmr">&minus;0</span><span class="ML__cmr">+</span><span class="ML__cmr">0</span><span class="ML__cmr">=</span><span class="ML__cmr">&minus;0</span></span></span></span><span class="lurch-atom-suffix"><span class="feedback-marker-valid">&nbsp;</span></span></span>. Commutativity of addition gives us <span class="lurch-atom" title="Good work!" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;0+(-0)=-0+0&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__cmr">0</span><span class="ML__cmr">+</span><span class="ML__left-right" style="margin-top: -0.08333em; height: 0.72777em;"><span class="ML__small-delim ML__open">(</span><span class="ML__cmr">&minus;0</span><span class="ML__small-delim ML__close">)</span></span><span class="ML__cmr">=</span><span class="ML__cmr">&minus;0</span><span class="ML__cmr">+</span><span class="ML__cmr">0</span></span></span></span><span class="lurch-atom-suffix"><span class="feedback-marker-valid">&nbsp;</span></span></span>, and then we have <span class="lurch-atom" title="Good work!" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;0+(-0)=-0&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__cmr">0</span><span class="ML__cmr">+</span><span class="ML__left-right" style="margin-top: -0.08333em; height: 0.72777em;"><span class="ML__small-delim ML__open">(</span><span class="ML__cmr">&minus;0</span><span class="ML__small-delim ML__close">)</span></span><span class="ML__cmr">=</span><span class="ML__cmr">&minus;0</span></span></span></span><span class="lurch-atom-suffix"><span class="feedback-marker-valid">&nbsp;</span></span></span> <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;by substitution&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">by substitution</span></span></span></span></span>, and <span class="lurch-atom" title="Good work!" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;-0=0&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__cmr">&minus;0</span><span class="ML__cmr">=</span><span class="ML__cmr">0</span></span></span></span><span class="lurch-atom-suffix"><span class="feedback-marker-valid">&nbsp;</span></span></span> <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;by substitution&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">by substitution</span></span></span></span></span> once more.</p>
</div>
<p>You may note that in the above proof, the phrase "by substitution" appears in orange. It has been typed&nbsp;<em>as its own separate mathematical expression,&nbsp;</em>because at the moment, Lurch needs help knowing when to apply the rule of substitution. We hope in a future version of Lurch to have streamlined our algorithms to the point where this is no longer necessary, but for now it is.</p>
<p>Furthermore, Lurch automatically treats expressions of the form <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expositorymath&quot;" data-metadata_latex="&quot;b-a&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">b</span><span class="ML__cmr">&minus;</span><span class="ML__mathit">a</span></span></span></span></span> as if they meant <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expositorymath&quot;" data-metadata_latex="&quot;b+(-a)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">b</span><span class="ML__cmr">+</span><span class="ML__cmr">(&minus;</span><span class="ML__mathit">a</span><span class="ML__cmr">)</span></span></span></span></span>, so we can stop writing the latter (awkward) form and use standard subtraction notation from here onward.</p>
<p>&nbsp;</p>
<div class="lurch-atom" title="Good work!" data-metadata_type="&quot;theorem&quot;" data-shell_title="Theorem:" data-validation_result="valid">
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;0*a=0&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__cmr">0</span><span class="ML__cmr">&sdot;</span><span class="ML__mathit">a</span><span class="ML__cmr">=</span><span class="ML__cmr">0</span></span></span></span><span class="lurch-atom-suffix"><span class="feedback-marker-valid">&nbsp;</span></span></span></p>
</div>
<div class="lurch-atom" title="Good work!" data-metadata_type="&quot;proof&quot;" data-shell_title="Proof:" data-validation_result="valid">
<p>Although it is possible to do this proof by axiomatically applying introduction and elimination rules for equality, it is quite tedious. Thus Lurch provides a feature (which has been enabled in the predicate logic rules on which this document depends) that, if it sees a chain of equalities like the one below, will attempt to justify each step in it by applying&nbsp; on your behalf symmetry of equality, transitivity of equality, and/or substitution. We can see that it is successful in this case; those tools are sufficient to justify the following chain of equalities, which prove the theorem.</p>
<p style="text-align: center;"><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;0\n= 0*a-0*a\n= (0-0)*a-0*a\n= (0*a-0*a)-0*a\n= (0*a+0*a)-0*a\n= 0*a+(0*a-0*a)\n= 0*a+0\n= 0*a&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mtable"><span class="col-align-r"><span class="ML__vlist-t ML__vlist-t2"><span class="ML__vlist-r"><span class="ML__vlist" style="height: 5.35em;"><span style="top: -7.51em;"><span style="height: 1.5em; display: inline-block;"><span class="ML__cmr">0</span></span></span></span><span class="ML__vlist-s">​</span></span></span></span><span class="col-align-l"><span class="ML__vlist-t ML__vlist-t2"><span class="ML__vlist-r"><span class="ML__vlist" style="height: 5.35em;"><span style="top: -7.51em;"><span style="height: 1.5em; display: inline-block;"><span class="ML__cmr">=</span><span class="ML__cmr">0</span><span class="ML__cmr">&sdot;</span><span class="ML__mathit">a</span><span class="ML__cmr">&minus;</span><span class="ML__cmr">0</span><span class="ML__cmr">&sdot;</span><span class="ML__mathit">a</span></span></span><span style="top: -6.01em;"><span style="height: 1.5em; display: inline-block;"><span class="ML__cmr">=</span><span class="ML__left-right" style="margin-top: -0.08333em; height: 0.72777em;"><span class="ML__small-delim ML__open">(</span><span class="ML__cmr">0</span><span class="ML__cmr">&minus;</span><span class="ML__cmr">0</span><span class="ML__small-delim ML__close">)</span></span><span class="ML__cmr">&sdot;</span><span class="ML__mathit">a</span><span class="ML__cmr">&minus;</span><span class="ML__cmr">0</span><span class="ML__cmr">&sdot;</span><span class="ML__mathit">a</span></span></span><span style="top: -4.51em;"><span style="height: 1.5em; display: inline-block;"><span class="ML__cmr">=</span><span class="ML__left-right" style="margin-top: -0.08333em; height: 0.72777em;"><span class="ML__small-delim ML__open">(</span><span class="ML__cmr">0</span><span class="ML__cmr">&sdot;</span><span class="ML__mathit">a</span><span class="ML__cmr">&minus;</span><span class="ML__cmr">0</span><span class="ML__cmr">&sdot;</span><span class="ML__mathit">a</span><span class="ML__small-delim ML__close">)</span></span><span class="ML__cmr">&minus;</span><span class="ML__cmr">0</span><span class="ML__cmr">&sdot;</span><span class="ML__mathit">a</span></span></span><span style="top: -3.01em;"><span style="height: 1.5em; display: inline-block;"><span class="ML__cmr">=</span><span class="ML__left-right" style="margin-top: -0.08333em; height: 0.72777em;"><span class="ML__small-delim ML__open">(</span><span class="ML__cmr">0</span><span class="ML__cmr">&sdot;</span><span class="ML__mathit">a</span><span class="ML__cmr">+</span><span class="ML__cmr">0</span><span class="ML__cmr">&sdot;</span><span class="ML__mathit">a</span><span class="ML__small-delim ML__close">)</span></span><span class="ML__cmr">&minus;</span><span class="ML__cmr">0</span><span class="ML__cmr">&sdot;</span><span class="ML__mathit">a</span></span></span><span style="top: -1.5em;"><span style="height: 1.5em; display: inline-block;"><span class="ML__cmr">=</span><span class="ML__cmr">0</span><span class="ML__cmr">&sdot;</span><span class="ML__mathit">a</span><span class="ML__cmr">+</span><span class="ML__left-right" style="margin-top: -0.08333em; height: 0.72777em;"><span class="ML__small-delim ML__open">(</span><span class="ML__cmr">0</span><span class="ML__cmr">&sdot;</span><span class="ML__mathit">a</span><span class="ML__cmr">&minus;</span><span class="ML__cmr">0</span><span class="ML__cmr">&sdot;</span><span class="ML__mathit">a</span><span class="ML__small-delim ML__close">)</span></span></span></span><span style="top: 0;"><span style="height: 1.5em; display: inline-block;"><span class="ML__cmr">=</span><span class="ML__cmr">0</span><span class="ML__cmr">&sdot;</span><span class="ML__mathit">a</span><span class="ML__cmr">+</span><span class="ML__cmr">0</span></span></span><span style="top: 1.49em;"><span style="height: 1.2em; display: inline-block;"><span class="ML__cmr">=</span><span class="ML__cmr">0</span><span class="ML__cmr">&sdot;</span><span class="ML__mathit">a</span></span></span></span><span class="ML__vlist-s">​</span></span></span></span></span></span></span></span><span class="lurch-atom-suffix"><span class="feedback-marker-valid">&nbsp;</span></span></span></p>
<p style="text-align: left;">This version of Lurch gives only one green check mark for the entire chain of equalities, signifying that every step within it is correct. In future versions, we aim to give feedback about each step within the chain.</p>
</div>
<p>&nbsp;</p>
<div class="lurch-atom" title="Good work!" data-metadata_type="&quot;theorem&quot;" data-shell_title="Theorem:" data-validation_result="valid">
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;If a*b=0&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">If </span><span class="ML__mathit">a</span><span class="ML__cmr">&sdot;</span><span class="ML__mathit">b</span><span class="ML__cmr">=</span><span class="ML__cmr">0</span></span></span></span></span> then either <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;a=0 or b=0&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">a</span><span class="ML__cmr">=</span><span class="ML__cmr">0</span><span class="ML__text"> or </span><span class="ML__mathit">b</span><span class="ML__cmr">=</span><span class="ML__cmr">0</span></span></span></span><span class="lurch-atom-suffix"><span class="feedback-marker-valid">&nbsp;</span></span></span>.</p>
</div>
<div class="lurch-atom" title="Good work!" data-metadata_type="&quot;proof&quot;" data-shell_title="Proof:" data-validation_result="valid">
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;Assume a*b=0&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">Assume </span><span class="ML__mathit">a</span><span class="ML__cmr">&sdot;</span><span class="ML__mathit">b</span><span class="ML__cmr">=</span><span class="ML__cmr">0</span></span></span></span></span>.</p>
<div class="lurch-atom" title="Good work!" data-metadata_type="&quot;subproof&quot;" data-shell_title="" data-validation_result="valid">
<p>Further <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;assume a neq 0&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">assume </span><span class="ML__mathit">a</span><span class="ML__rlap"><span class="ML__inner"><span class="ML__cmr"></span></span></span><span class="ML__cmr">=</span><span class="ML__cmr">0</span></span></span></span></span>. Then the following holds. Notice that Lurch is able to figure out which axioms to apply in each case.</p>
<p style="text-align: center;"><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;b\n= b*1\n= b*(a*(1/a))\n= (b*a)*(1/a)\n= (a*b)*(1/a)\n= 0*(1/a)\n= 0&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mtable"><span class="col-align-r"><span class="ML__vlist-t ML__vlist-t2"><span class="ML__vlist-r"><span class="ML__vlist" style="height: 5.88em;"><span style="top: -8.18em;"><span style="height: 1.5em; display: inline-block;"><span class="ML__mathit">b</span></span></span></span><span class="ML__vlist-s">​</span></span></span></span><span class="col-align-l"><span class="ML__vlist-t ML__vlist-t2"><span class="ML__vlist-r"><span class="ML__vlist" style="height: 5.88em;"><span style="top: -8.18em;"><span style="height: 1.5em; display: inline-block;"><span class="ML__cmr">=</span><span class="ML__mathit">b</span><span class="ML__cmr">&sdot;</span><span class="ML__cmr">1</span></span></span><span style="top: -6.37em;"><span style="height: 2.14em; display: inline-block;"><span class="ML__cmr">=</span><span class="ML__mathit">b</span><span class="ML__cmr">&sdot;</span><span class="ML__left-right" style="margin-top: -0.686em; height: 1.8359999999999999em;"><span class="ML__open ML__delim-size2">(</span><span class="ML__mathit">a</span><span class="ML__cmr">&sdot;</span><span class="ML__left-right" style="margin-top: -0.686em; height: 1.8304399999999998em;"><span class="ML__open ML__delim-size2">(</span><span class="ML__mfrac"><span class="ML__vlist-t ML__vlist-t2"><span class="ML__vlist-r"><span class="ML__vlist" style="height: 1.15em;"><span class="ML__center" style="top: -2.31em;"><span style="height: 0.44em; display: inline-block;"><span class="ML__mathit">a</span></span></span><span class="ML__center" style="top: -3.5em;"><span style="height: 0.65em; display: inline-block;"><span class="ML__cmr">1</span></span></span></span><span class="ML__vlist-s">​</span></span></span></span><span class="ML__close ML__delim-size2">)</span></span><span class="ML__close ML__delim-size2">)</span></span></span></span><span style="top: -4.23em;"><span style="height: 2.14em; display: inline-block;"><span class="ML__cmr">=</span><span class="ML__left-right" style="margin-top: 0em; height: 0.69444em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">b</span><span class="ML__cmr">&sdot;</span><span class="ML__mathit">a</span><span class="ML__small-delim ML__close">)</span></span><span class="ML__cmr">&sdot;</span><span class="ML__left-right" style="margin-top: -0.686em; height: 1.8304399999999998em;"><span class="ML__open ML__delim-size2">(</span><span class="ML__mfrac"><span class="ML__vlist-t ML__vlist-t2"><span class="ML__vlist-r"><span class="ML__vlist" style="height: 1.15em;"><span class="ML__center" style="top: -2.31em;"><span style="height: 0.44em; display: inline-block;"><span class="ML__mathit">a</span></span></span><span class="ML__center" style="top: -3.5em;"><span style="height: 0.65em; display: inline-block;"><span class="ML__cmr">1</span></span></span></span><span class="ML__vlist-s">​</span></span></span></span><span class="ML__close ML__delim-size2">)</span></span></span></span><span style="top: -2.1em;"><span style="height: 2.14em; display: inline-block;"><span class="ML__cmr">=</span><span class="ML__left-right" style="margin-top: 0em; height: 0.69444em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">a</span><span class="ML__cmr">&sdot;</span><span class="ML__mathit">b</span><span class="ML__small-delim ML__close">)</span></span><span class="ML__cmr">&sdot;</span><span class="ML__left-right" style="margin-top: -0.686em; height: 1.8304399999999998em;"><span class="ML__open ML__delim-size2">(</span><span class="ML__mfrac"><span class="ML__vlist-t ML__vlist-t2"><span class="ML__vlist-r"><span class="ML__vlist" style="height: 1.15em;"><span class="ML__center" style="top: -2.31em;"><span style="height: 0.44em; display: inline-block;"><span class="ML__mathit">a</span></span></span><span class="ML__center" style="top: -3.5em;"><span style="height: 0.65em; display: inline-block;"><span class="ML__cmr">1</span></span></span></span><span class="ML__vlist-s">​</span></span></span></span><span class="ML__close ML__delim-size2">)</span></span></span></span><span style="top: 0.04em;"><span style="height: 2.14em; display: inline-block;"><span class="ML__cmr">=</span><span class="ML__cmr">0</span><span class="ML__cmr">&sdot;</span><span class="ML__left-right" style="margin-top: -0.686em; height: 1.8304399999999998em;"><span class="ML__open ML__delim-size2">(</span><span class="ML__mfrac"><span class="ML__vlist-t ML__vlist-t2"><span class="ML__vlist-r"><span class="ML__vlist" style="height: 1.15em;"><span class="ML__center" style="top: -2.31em;"><span style="height: 0.44em; display: inline-block;"><span class="ML__mathit">a</span></span></span><span class="ML__center" style="top: -3.5em;"><span style="height: 0.65em; display: inline-block;"><span class="ML__cmr">1</span></span></span></span><span class="ML__vlist-s">​</span></span></span></span><span class="ML__close ML__delim-size2">)</span></span></span></span><span style="top: 1.87em;"><span style="height: 1.2em; display: inline-block;"><span class="ML__cmr">=</span><span class="ML__cmr">0</span></span></span></span><span class="ML__vlist-s">​</span></span></span></span></span></span></span></span><span class="lurch-atom-suffix"><span class="feedback-marker-valid">&nbsp;</span></span></span></p>
<p style="text-align: left;">At the moment, it's necessary to wrap <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expositorymath&quot;" data-metadata_latex="&quot;\\frac 1 a&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mfrac"><span class="ML__vlist-t ML__vlist-t2"><span class="ML__vlist-r"><span class="ML__vlist" style="height: 1.15em;"><span class="ML__center" style="top: -2.31em;"><span style="height: 0.44em; display: inline-block;"><span class="ML__mathit">a</span></span></span><span class="ML__center" style="top: -3.5em;"><span style="height: 0.65em; display: inline-block;"><span class="ML__cmr">1</span></span></span></span><span class="ML__vlist-s">​</span></span></span></span></span></span></span></span> in parentheses in meaningful expressions, or the parser may misunderstand it. Improvements to the parser (and the goal of making all notation customizable) are planned for the future.</p>
</div>
<p>The above subproof shows that <span class="lurch-atom" title="Good work!" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;a neq 0 implies b=0&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">a</span><span class="ML__rlap"><span class="ML__inner"><span class="ML__cmr"></span></span></span><span class="ML__cmr">=</span><span class="ML__cmr">0</span><span class="ML__cmr">&rArr;</span><span class="ML__mathit">b</span><span class="ML__cmr">=</span><span class="ML__cmr">0</span></span></span></span><span class="lurch-atom-suffix"><span class="feedback-marker-valid">&nbsp;</span></span></span>. That is logically equivalent to our goal, <span class="lurch-atom" title="Good work!" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;a=0 or b=0&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">a</span><span class="ML__cmr">=</span><span class="ML__cmr">0</span><span class="ML__text"> or </span><span class="ML__mathit">b</span><span class="ML__cmr">=</span><span class="ML__cmr">0</span></span></span></span><span class="lurch-atom-suffix"><span class="feedback-marker-valid">&nbsp;</span></span></span>, but Lurch does not know that because we have not proven that propositional equivalence yet. We do so with a few steps here.</p>
<div class="lurch-atom" title="Good work!" data-metadata_type="&quot;subproof&quot;" data-shell_title="" data-validation_result="valid">
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;Assume not(a=0 or b=0)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">Assume not </span><span class="ML__left-right" style="margin-top: 0em; height: 0.69444em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">a</span><span class="ML__cmr">=</span><span class="ML__cmr">0</span><span class="ML__text"> or </span><span class="ML__mathit">b</span><span class="ML__cmr">=</span><span class="ML__cmr">0</span><span class="ML__small-delim ML__close">)</span></span></span></span></span></span>.</p>
<div class="lurch-atom" title="Good work!" data-metadata_type="&quot;subproof&quot;" data-shell_title="" data-validation_result="valid">
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;Assume a=0&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">Assume </span><span class="ML__mathit">a</span><span class="ML__cmr">=</span><span class="ML__cmr">0</span></span></span></span></span>. Then <span class="lurch-atom" title="Good work!" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;a=0 or b=0&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">a</span><span class="ML__cmr">=</span><span class="ML__cmr">0</span><span class="ML__text"> or </span><span class="ML__mathit">b</span><span class="ML__cmr">=</span><span class="ML__cmr">0</span></span></span></span><span class="lurch-atom-suffix"><span class="feedback-marker-valid">&nbsp;</span></span></span>, which is a contradiction.</p>
</div>
<p>So we have <span class="lurch-atom" title="Good work!" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;a neq 0&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">a</span><span class="ML__rlap"><span class="ML__inner"><span class="ML__cmr"></span></span></span><span class="ML__cmr">=</span><span class="ML__cmr">0</span></span></span></span><span class="lurch-atom-suffix"><span class="feedback-marker-valid">&nbsp;</span></span></span>, and thus we have <span class="lurch-atom" title="Good work!" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;b=0&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">b</span><span class="ML__cmr">=</span><span class="ML__cmr">0</span></span></span></span><span class="lurch-atom-suffix"><span class="feedback-marker-valid">&nbsp;</span></span></span>, but that also implies <span class="lurch-atom" title="Good work!" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;a=0 or b=0&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">a</span><span class="ML__cmr">=</span><span class="ML__cmr">0</span><span class="ML__text"> or </span><span class="ML__mathit">b</span><span class="ML__cmr">=</span><span class="ML__cmr">0</span></span></span></span><span class="lurch-atom-suffix"><span class="feedback-marker-valid">&nbsp;</span></span></span>, again a contradiction.</p>
</div>
<p>So we have shown <span class="lurch-atom" title="Good work!" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;a=0 or b=0&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">a</span><span class="ML__cmr">=</span><span class="ML__cmr">0</span><span class="ML__text"> or </span><span class="ML__mathit">b</span><span class="ML__cmr">=</span><span class="ML__cmr">0</span></span></span></span><span class="lurch-atom-suffix"><span class="feedback-marker-valid">&nbsp;</span></span></span>.</p>
</div>
<p>&nbsp;</p>
<h2>Try it!</h2>
<p>Now that you've seen how we can prove some real mathematical facts (albeit basic ones, axiomatically), you may want to try some exercises on your own. We provide them in a separate document in this tutorial series, so that when you're asking Lurch to check your work, you don't have to wait while it also re-checks the theorems we've proven above. But those three theorems will be imported in the exercises so that you can rely on them.</p></div>
        


            <div id="loadlink">
                <p><a>Open this file in the Lurch web app</a></p>
                <script language="javascript">
                    const link = document.querySelector( '#loadlink > p > a' )
                    const thisURL = encodeURIComponent( window.location.href )
                    link?.setAttribute( 'href', 'http://localhost:64157/app/?load=' + thisURL )
                </script>
            </div>
        
            <div id="metadata" style="display: none;"><div data-category="main" data-key="header" data-value-type="html"><div class="lurch-atom" contenteditable="false" data-metadata_type="&quot;dependency&quot;" data-metadata_description="&quot;none&quot;" data-metadata_filename="&quot;../math/predicate-logic-rules.lurch&quot;" data-metadata_source="&quot;the web&quot;" data-metadata_auto-refresh="true" style="border: 1px solid gray; padding: 0px 1em;"><div class="lurch-atom-metadata" style="display: none;"><div data-key="content">
            <div id="loadlink">
                <p><a>Open this file in the Lurch web app</a></p>
                
            </div>
        
            <div id="metadata" style="display: none;"><div data-category="main" data-key="header" data-value-type="html"><div class="lurch-atom" contenteditable="false" data-metadata_type="&quot;dependency&quot;" data-metadata_description="&quot;none&quot;" data-metadata_filename="&quot;../math/propositional-logic-rules.lurch&quot;" data-metadata_source="&quot;the web&quot;" data-metadata_auto-refresh="true" style="border: 1px solid gray; padding: 0px 1em;"><div class="lurch-atom-metadata" style="display: none;"><div data-key="content">
            <div id="loadlink">
                <p><a>Open this file in the Lurch web app</a></p>
                
            </div>
        
            <div id="metadata" style="display: none;"><div data-category="settings" data-key="shell style" data-value-type="json">"boxed"</div></div>
            <div id="document"><h1>Rules for Propositional Logic</h1>
<p>There are many ways to express the rules for propositional logic, but here is one way. We don't use these rules for any proofs in this document; it's just the set of rules. See the table of contents for this tutorial site for examples of how to import and use these rules.</p>
<p><span style="text-decoration: underline;"><strong>Tip:</strong></span> Try viewing the document below in two different modes, by clicking the Document menu, then choosing "Show/hide meaning." One view shows every expression and environment clearly designated by colors and borders, while the other view keeps everything minimalist and black-and-white. You can switch between these views easily with the keyboard shortcut Alt+0. Which do you prefer?</p>
<h2>Operators</h2>
<p>In Lurch, we must declare up front which symbols are the operators and other constants that we're using, so that they are not later treated as variables:&nbsp;<span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;Declare and, or, not, implies, iff&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">Declare and, or, </span><span class="ML__ams">¬</span><span class="ML__text">, </span><span class="ML__cmr">⇒</span><span class="ML__text">, and </span><span class="ML__cmr">⇔</span></span></span></span></span>.</p>
<h2>Rules for conjunction</h2>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Conjunction introduction:</p>
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;Assume A&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">Assume </span><span class="ML__mathit">A</span></span></span></span></span> and further <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;assume B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">assume </span><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span>. Then we can conclude <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;A and B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">A</span><span class="ML__text"> and </span><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span>.</p>
</div>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Conjunction elimination:</p>
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;Assume A and B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">Assume </span><span class="ML__mathit">A</span><span class="ML__text"> and </span><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span>. Then we can conclude <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;A&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">A</span></span></span></span></span>, or we could instead conclude <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span>, or both.</p>
</div>
<h2>Rules for disjunction</h2>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Disjunction introduction:</p>
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;Assume A&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">Assume </span><span class="ML__mathit">A</span></span></span></span></span>. Then we can conclude <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;A or B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">A</span><span class="ML__text"> or </span><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span>, and we can also conclude <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;B or A&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit" style="margin-right: 0.06em;">B</span><span class="ML__text"> or </span><span class="ML__mathit">A</span></span></span></span></span>.</p>
</div>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Disjunction elimination:</p>
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;Assume A or B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">Assume </span><span class="ML__mathit">A</span><span class="ML__text"> or </span><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span>. Then we can proceed in one of two ways.</p>
<div class="lurch-atom" data-metadata_type="&quot;subproof&quot;" data-shell_title="">
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;If not A&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">If not </span><span class="ML__mathit">A</span></span></span></span></span> is true, then we can conclude that <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span> must be true.</p>
</div>
<div class="lurch-atom" data-metadata_type="&quot;subproof&quot;" data-shell_title="">
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;If not B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">If not </span><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span> is true, then we can conclude that <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;A&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">A</span></span></span></span></span> must be true.</p>
</div>
</div>
<h2>Rules for conditional</h2>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Conditional introduction:</p>
<div class="lurch-atom" data-metadata_type="&quot;premise&quot;" data-shell_title="">
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;Assume A&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">Assume </span><span class="ML__mathit">A</span></span></span></span></span> at the start of a subproof.</p>
<p>Do whatever work is necessary in that subproof to conclude <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span>.</p>
</div>
<p>Then outside the subproof, you can conclude&nbsp;<span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;A implies B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">A</span><span class="ML__cmr">⇒</span><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span>.</p>
</div>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Conditional elimination:</p>
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;Assume A&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">Assume </span><span class="ML__mathit">A</span></span></span></span></span> and further assume <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;A implies B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">A</span><span class="ML__cmr">⇒</span><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span>. Then we can conclude <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span>.</p>
</div>
<h2>Rules for negation</h2>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Negation introduction:</p>
<div class="lurch-atom" data-metadata_type="&quot;premise&quot;" data-shell_title="">
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;Assume A&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">Assume </span><span class="ML__mathit">A</span></span></span></span></span> towards a contradiction at the start of a subproof.</p>
<p>Do whatever work is necessary in that subproof to conclude a contradiction, such as <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span> and <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;not B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">not </span><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span>.</p>
</div>
<p>Then outside the subproof, you can conclude <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;not A&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">not </span><span class="ML__mathit">A</span></span></span></span></span>.</p>
</div>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Negation elimination:</p>
<div class="lurch-atom" data-metadata_type="&quot;premise&quot;" data-shell_title="">
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;Assume not A&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">Assume not </span><span class="ML__mathit">A</span></span></span></span></span> towards a contradiction at the start of a subproof.</p>
<p>Do whatever work is necessary in that subproof to conclude a contradiction, such as <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span> and <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;not B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">not </span><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span>.</p>
</div>
<p>Then outside the subproof, you can conclude <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;A&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">A</span></span></span></span></span>.</p>
</div>
<h2>Rules for biconditional</h2>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Biconditional introduction:</p>
<div class="lurch-atom" data-metadata_type="&quot;premise&quot;" data-shell_title="">
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;Assume A&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">Assume </span><span class="ML__mathit">A</span></span></span></span></span> at the start of a subproof.</p>
<p>Do whatever work is necessary in that subproof to conclude <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span>.</p>
</div>
<div class="lurch-atom" data-metadata_type="&quot;premise&quot;" data-shell_title="">
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;Assume B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">Assume </span><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span> at the start of a second subproof.</p>
<p>Do whatever work is necessary in that subproof to conclude <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;A&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">A</span></span></span></span></span>.</p>
</div>
<p>Then outside of both subproofs, you can conclude <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;A iff B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">A</span><span class="ML__cmr">⇔</span><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span>.</p>
</div>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Biconditional elimination:</p>
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;Assume A iff B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">Assume </span><span class="ML__mathit">A</span><span class="ML__cmr">⇔</span><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span>. Then we can proceed in one of two ways.</p>
<div class="lurch-atom" data-metadata_type="&quot;subproof&quot;" data-shell_title="">
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;If A&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">If </span><span class="ML__mathit">A</span></span></span></span></span> is true, from it, we can conclude <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span>.</p>
</div>
<div class="lurch-atom" data-metadata_type="&quot;subproof&quot;" data-shell_title="">
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;If B&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">If </span><span class="ML__mathit" style="margin-right: 0.06em;">B</span></span></span></span></span> is true, from it, we can conclude <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;A&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">A</span></span></span></span></span>.</p>
</div>
</div>
<p>&nbsp;</p></div>
        </div></div><div class="lurch-atom-body"><table><colgroup><col><col></colgroup><tbody><tr><td colspan="2"><b>Imported dependency document</b></td></tr><tr><td>Description:</td><td><tt>none</tt></td></tr><tr><td>Filename:</td><td><tt>../math/propositional-logic-rules.lurch</tt></td></tr><tr><td>Source:</td><td>the web</td></tr><tr><td>Auto-refresh:</td><td>yes</td></tr></tbody></table></div></div></div></div>
            <div id="document"><h1>Rules for Predicate Logic</h1>
<p>This document imports the rules for propositional logic, and augments them with the new rules below.</p>
<h2>Rules for universal quantification</h2>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Universal introduction:</p>
<div class="lurch-atom" data-metadata_type="&quot;premise&quot;" data-shell_title="">
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;Let x&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">Let </span><span class="ML__mathit">x</span></span></span></span></span> be arbitrary inside a new subproof, like this one. Then do whatever work is necessary to prove some conclusion <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;@P(x)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__cal" style="margin-right: 0.09em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">x</span><span class="ML__small-delim ML__close">)</span></span></span></span></span></span> about <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expositorymath&quot;" data-metadata_latex="&quot;x&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">x</span></span></span></span></span>.</p>
</div>
<p>Based on that subproof, and outside of that subproof, you can then conclude <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;forall x. @P(x)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__cmr">∀</span><span class="ML__mathit">x</span><span class="ML__cmr">.</span><span class="ML__cal" style="margin-right: 0.09em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">x</span><span class="ML__small-delim ML__close">)</span></span></span></span></span></span>.</p>
</div>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Universal elimination:</p>
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;If forall x.@P(x)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">If </span><span class="ML__cmr">∀</span><span class="ML__mathit">x</span><span class="ML__cmr">.</span><span class="ML__cal" style="margin-right: 0.09em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">x</span><span class="ML__small-delim ML__close">)</span></span></span></span></span></span> is true, then we can apply it to any particular target, as in <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;@P(t)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__cal" style="margin-right: 0.09em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.61508em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">t</span><span class="ML__small-delim ML__close">)</span></span></span></span></span></span>.</p>
</div>
<h2>Rules for existential quantification</h2>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Existential introduction:</p>
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;If @P(t)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">If </span><span class="ML__cal" style="margin-right: 0.09em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.61508em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">t</span><span class="ML__small-delim ML__close">)</span></span></span></span></span></span> holds for any particular thing <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expositorymath&quot;" data-metadata_latex="&quot;t&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">t</span></span></span></span></span>, then we can say <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;exists x.@P(x)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__cmr">∃</span><span class="ML__mathit">x</span><span class="ML__cmr">.</span><span class="ML__cal" style="margin-right: 0.09em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">x</span><span class="ML__small-delim ML__close">)</span></span></span></span></span></span>.</p>
</div>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Existential elimination:</p>
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;If exists x.@P(x)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">If </span><span class="ML__cmr">∃</span><span class="ML__mathit">x</span><span class="ML__cmr">.</span><span class="ML__cal" style="margin-right: 0.09em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">x</span><span class="ML__small-delim ML__close">)</span></span></span></span></span></span>, then we can choose a name for the object that we know exists, allowing us to discuss the object in our proof, stating <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;@P(c) for some c&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__cal" style="margin-right: 0.09em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">c</span><span class="ML__small-delim ML__close">)</span></span><span class="ML__text"> for some </span><span class="ML__mathit">c</span></span></span></span></span>.&nbsp; We choose the name <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expositorymath&quot;" data-metadata_latex="&quot;c&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">c</span></span></span></span></span> because some refer to the symbol as a "constant."</p>
</div>
<h2>Rules for equality</h2>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Equality introduction:</p>
<p>You can write <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;x=x&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">x</span><span class="ML__cmr">=</span><span class="ML__mathit">x</span></span></span></span></span> for any term <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expositorymath&quot;" data-metadata_latex="&quot;x&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">x</span></span></span></span></span>.</p>
</div>
<div class="lurch-atom" data-metadata_type="&quot;rule&quot;" data-shell_title="Rule:">
<p>Equality elimination:</p>
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;If a=b&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">If </span><span class="ML__mathit">a</span><span class="ML__cmr">=</span><span class="ML__mathit">b</span></span></span></span></span> then we can use that equation for substitution.&nbsp; In particular, <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;if @P(a)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">if </span><span class="ML__cal" style="margin-right: 0.09em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">a</span><span class="ML__small-delim ML__close">)</span></span></span></span></span></span> for any statement <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expositorymath&quot;" data-metadata_latex="&quot;\\mathcal{P}&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__cal" style="margin-right: 0.09em;">P</span></span></span></span></span>, then we can conclude <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;@P(b)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__cal" style="margin-right: 0.09em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.69444em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">b</span><span class="ML__small-delim ML__close">)</span></span></span></span></span></span> for the same statement <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expositorymath&quot;" data-metadata_latex="&quot;\\mathcal{P}&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__cal" style="margin-right: 0.09em;">P</span></span></span></span></span>.</p>
</div></div>
        </div></div><div class="lurch-atom-body"><table><colgroup><col><col></colgroup><tbody><tr><td colspan="2"><b>Imported dependency document</b></td></tr><tr><td>Description:</td><td><tt>none</tt></td></tr><tr><td>Filename:</td><td><tt>../math/predicate-logic-rules.lurch</tt></td></tr><tr><td>Source:</td><td>the web</td></tr><tr><td>Auto-refresh:</td><td>yes</td></tr></tbody></table></div></div></div></div>
            <div id="document"><h1>Beyond Propositional Logic</h1>
<h2>Predicate logic without the pain</h2>
<p>If we want to use Lurch to do real mathematics, our propositions can't be just atomic letters, like <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expositorymath&quot;" data-metadata_latex="&quot;P&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit" style="margin-right: 0.14em;">P</span></span></span></span></span> and <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expositorymath&quot;" data-metadata_latex="&quot;Q&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">Q</span></span></span></span></span>. We need to be able to reason about actual mathematical statements, like&nbsp;<span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expositorymath&quot;" data-metadata_latex="&quot;x&lt;0&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">x</span><span class="ML__cmr">&lt;</span><span class="ML__cmr">0</span></span></span></span></span> and <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expositorymath&quot;" data-metadata_latex="&quot;a\\notin\\{1,3,5\\}&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">a</span><span class="ML__cmr">&notin;</span><span class="ML__cmr">{1,</span><span class="ML__cmr">3,</span><span class="ML__cmr">5}</span></span></span></span></span>. Such statements typically contain variables, which requires us to use the rules of predicate logic.</p>
<p>Those rules (introduction and elimination rules for the quantifiers <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expositorymath&quot;" data-metadata_latex="&quot;\\forall&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__cmr">&forall;</span></span></span></span></span> and <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expositorymath&quot;" data-metadata_latex="&quot;\\exists&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__cmr">&exist;</span></span></span></span></span>) are notorious for being difficult to explain simply and correctly. Most presentations of logic introduce complex and difficult-to-motivate constraints on how one applies the rules of predicate logic, such as "the variable must not appear free in any premise or undischarged assumption."</p>
<p>In Lurch, we avoid these rules by providing users with the tools needed to declare variables in several standard mathematical ways, and then write rules of logic that use variable declarations and enforce standard scoping rules. This a user who is designing a system of predicate logic in Lurch to use a style like the one advocated in <a href="https://doi.org/10.1016/j.apal.2006.05.009" target="_blank" rel="noopener">this article</a>, in which variable scopes ensure that the system is sound, without the need for any additional restrictions on when rules might apply.</p>
<p>Try showing/hiding the rules imported in this document, which define rules for the two standard quantifiers. Note that if you are using Lurch Notation, quantified statements are expressed as in the following two examples.</p>
<p style="padding-left: 40px;"><code>forall x. P(x)</code> means <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expositorymath&quot;" data-metadata_latex="&quot;\\forall x.P(x)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__cmr">&forall;</span><span class="ML__mathit">x</span><span class="ML__cmr">.</span><span class="ML__mathit" style="margin-right: 0.14em;">P</span><span class="ML__cmr">(</span><span class="ML__mathit">x</span><span class="ML__cmr">)</span></span></span></span></span></p>
<p style="padding-left: 40px;"><code>exists y. 0&lt;y</code> means <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expositorymath&quot;" data-metadata_latex="&quot;\\exists y.0&lt;y&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__cmr">&exist;</span><span class="ML__mathit" style="margin-right: 0.04em;">y</span><span class="ML__cmr">.0</span><span class="ML__cmr">&lt;</span><span class="ML__mathit" style="margin-right: 0.04em;">y</span></span></span></span></span></p>
<p>In particular, note that the symbols are written just as they are in LaTeX but omitting the backslash (\), and the variable being quantified is followed immediately by a period (.).</p>
<h2>How we do it</h2>
<p>In this section, we prove four famous theorems of predicate logic, De Morgan's laws. Each lets us give a little explanation of how variable declarations work in predicate logic, and how they work nicely with quantifiers to form a robust system of logic. Later documents in this tutorial will prove actual mathematical facts built on predicate logic, and will use variable declarations frequently, so this is an important foundation.</p>
<p>We add plenty of exposition among the rather simple proofs below, so that the reader can see how the quantifier rules and variable declarations are being used. Obviously, the proofs would be much shorter without this "tutorial" aspect of their content.</p>
<p>&nbsp;</p>
<div class="lurch-atom" title="Good work!" data-metadata_type="&quot;theorem&quot;" data-shell_title="Theorem:" data-validation_result="valid">
<p>De Morgan's Law, Part 1 of 4: <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;If exists x.P(x)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">If </span><span class="ML__cmr">&exist;</span><span class="ML__mathit">x</span><span class="ML__cmr">.</span><span class="ML__mathit" style="margin-right: 0.14em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">x</span><span class="ML__small-delim ML__close">)</span></span></span></span></span></span> then <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;not (forall x. not P(x))&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">not </span><span class="ML__left-right" style="margin-top: -0.25em; height: 1em;"><span class="ML__small-delim ML__open">(</span><span class="ML__cmr">&forall;</span><span class="ML__mathit">x</span><span class="ML__cmr">.</span><span class="ML__text">not </span><span class="ML__mathit" style="margin-right: 0.14em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">x</span><span class="ML__small-delim ML__close">)</span></span><span class="ML__small-delim ML__close">)</span></span></span></span></span><span class="lurch-atom-suffix"><span class="feedback-marker-valid">&nbsp;</span></span></span>.</p>
</div>
<div class="lurch-atom" title="Good work!" data-metadata_type="&quot;proof&quot;" data-shell_title="Proof:" data-validation_result="valid">
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;Assume exists x.P(x)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">Assume </span><span class="ML__cmr">&exist;</span><span class="ML__mathit">x</span><span class="ML__cmr">.</span><span class="ML__mathit" style="margin-right: 0.14em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">x</span><span class="ML__small-delim ML__close">)</span></span></span></span></span></span>. At this point, many authors would begin using the variable <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expositorymath&quot;" data-metadata_latex="&quot;x&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">x</span></span></span></span></span> as if it had been declared in the proof and had the property <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expositorymath&quot;" data-metadata_latex="&quot;P(x)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit" style="margin-right: 0.14em;">P</span><span class="ML__cmr">(</span><span class="ML__mathit">x</span><span class="ML__cmr">)</span></span></span></span></span>. But in reality, we have merely made an existential claim without declaring a variable. To get in our proof a variable for which <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expositorymath&quot;" data-metadata_latex="&quot;P&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit" style="margin-right: 0.14em;">P</span></span></span></span></span> holds, we must explicitly declare one. We use the phrase "for some" to do so, as follows: <span class="lurch-atom" title="Good work!" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;P(c) for some c&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit" style="margin-right: 0.14em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">c</span><span class="ML__small-delim ML__close">)</span></span><span class="ML__text"> for some </span><span class="ML__mathit">c</span></span></span></span><span class="lurch-atom-suffix"><span class="feedback-marker-valid">&nbsp;</span></span></span>.</p>
<div class="lurch-atom" title="Good work!" data-metadata_type="&quot;subproof&quot;" data-shell_title="" data-validation_result="valid">
<p>Now, towards a contradiction, we <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;assume forall x.not P(x)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">assume </span><span class="ML__cmr">&forall;</span><span class="ML__mathit">x</span><span class="ML__cmr">.</span><span class="ML__text">not </span><span class="ML__mathit" style="margin-right: 0.14em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">x</span><span class="ML__small-delim ML__close">)</span></span></span></span></span></span>. We can then apply that universal statement to the <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expositorymath&quot;" data-metadata_latex="&quot;c&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit">c</span></span></span></span></span> we declared above, getting <span class="lurch-atom" title="Good work!" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;not P(c)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">not </span><span class="ML__mathit" style="margin-right: 0.14em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">c</span><span class="ML__small-delim ML__close">)</span></span></span></span></span><span class="lurch-atom-suffix"><span class="feedback-marker-valid">&nbsp;</span></span></span>, which contradicts the fact preceding this subproof.</p>
</div>
<p>The above subproof achieves our goal of <span class="lurch-atom" title="Good work!" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;not (forall x.not P(x))&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">not </span><span class="ML__left-right" style="margin-top: -0.25em; height: 1em;"><span class="ML__small-delim ML__open">(</span><span class="ML__cmr">&forall;</span><span class="ML__mathit">x</span><span class="ML__cmr">.</span><span class="ML__text">not </span><span class="ML__mathit" style="margin-right: 0.14em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">x</span><span class="ML__small-delim ML__close">)</span></span><span class="ML__small-delim ML__close">)</span></span></span></span></span><span class="lurch-atom-suffix"><span class="feedback-marker-valid">&nbsp;</span></span></span> by contradiction.</p>
</div>
<p>&nbsp;</p>
<div class="lurch-atom" title="Good work!" data-metadata_type="&quot;theorem&quot;" data-shell_title="Theorem:" data-validation_result="valid">
<p>De Morgan's Law, Part 2 of 4:&nbsp;<span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;If forall x.P(x)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">If </span><span class="ML__cmr">&forall;</span><span class="ML__mathit">x</span><span class="ML__cmr">.</span><span class="ML__mathit" style="margin-right: 0.14em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">x</span><span class="ML__small-delim ML__close">)</span></span></span></span></span></span> then <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;not (exists x.not P(x))&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">not </span><span class="ML__left-right" style="margin-top: -0.25em; height: 1em;"><span class="ML__small-delim ML__open">(</span><span class="ML__cmr">&exist;</span><span class="ML__mathit">x</span><span class="ML__cmr">.</span><span class="ML__text">not </span><span class="ML__mathit" style="margin-right: 0.14em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">x</span><span class="ML__small-delim ML__close">)</span></span><span class="ML__small-delim ML__close">)</span></span></span></span></span><span class="lurch-atom-suffix"><span class="feedback-marker-valid">&nbsp;</span></span></span>.</p>
</div>
<div class="lurch-atom" title="Good work!" data-metadata_type="&quot;proof&quot;" data-shell_title="Proof:" data-validation_result="valid">
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;Assume forall x.P(x)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">Assume </span><span class="ML__cmr">&forall;</span><span class="ML__mathit">x</span><span class="ML__cmr">.</span><span class="ML__mathit" style="margin-right: 0.14em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">x</span><span class="ML__small-delim ML__close">)</span></span></span></span></span></span>.</p>
<div class="lurch-atom" title="Good work!" data-metadata_type="&quot;subproof&quot;" data-shell_title="" data-validation_result="valid">
<p>Now <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;assume exists x.not P(x)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">assume </span><span class="ML__cmr">&exist;</span><span class="ML__mathit">x</span><span class="ML__cmr">.</span><span class="ML__text">not </span><span class="ML__mathit" style="margin-right: 0.14em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">x</span><span class="ML__small-delim ML__close">)</span></span></span></span></span></span> towards a contradiction. Just as in the proof above, we know of the existence of something, but have not named it, so we do so here: <span class="lurch-atom" title="Good work!" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;not P(c) for some c&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">not </span><span class="ML__mathit" style="margin-right: 0.14em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">c</span><span class="ML__small-delim ML__close">)</span></span><span class="ML__text"> for some </span><span class="ML__mathit">c</span></span></span></span><span class="lurch-atom-suffix"><span class="feedback-marker-valid">&nbsp;</span></span></span>. But according to the assumption of the theorem, we also have <span class="lurch-atom" title="Good work!" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;P(c)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit" style="margin-right: 0.14em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">c</span><span class="ML__small-delim ML__close">)</span></span></span></span></span><span class="lurch-atom-suffix"><span class="feedback-marker-valid">&nbsp;</span></span></span>, which is a contradiction.</p>
</div>
<p>So we have shown our goal by contradiction using the above subproof, <span class="lurch-atom" title="Good work!" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;not (exists x.not P(x))&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">not </span><span class="ML__left-right" style="margin-top: -0.25em; height: 1em;"><span class="ML__small-delim ML__open">(</span><span class="ML__cmr">&exist;</span><span class="ML__mathit">x</span><span class="ML__cmr">.</span><span class="ML__text">not </span><span class="ML__mathit" style="margin-right: 0.14em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">x</span><span class="ML__small-delim ML__close">)</span></span><span class="ML__small-delim ML__close">)</span></span></span></span></span><span class="lurch-atom-suffix"><span class="feedback-marker-valid">&nbsp;</span></span></span>.</p>
</div>
<p>&nbsp;</p>
<div class="lurch-atom" title="Good work!" data-metadata_type="&quot;theorem&quot;" data-shell_title="Theorem:" data-validation_result="valid">
<p>De Morgan's Law, Part 3 of 4: <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;If not(exists x.P(x))&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">If not </span><span class="ML__left-right" style="margin-top: -0.25em; height: 1em;"><span class="ML__small-delim ML__open">(</span><span class="ML__cmr">&exist;</span><span class="ML__mathit">x</span><span class="ML__cmr">.</span><span class="ML__mathit" style="margin-right: 0.14em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">x</span><span class="ML__small-delim ML__close">)</span></span><span class="ML__small-delim ML__close">)</span></span></span></span></span></span> then <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;forall x.not P(x)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__cmr">&forall;</span><span class="ML__mathit">x</span><span class="ML__cmr">.</span><span class="ML__text">not </span><span class="ML__mathit" style="margin-right: 0.14em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">x</span><span class="ML__small-delim ML__close">)</span></span></span></span></span><span class="lurch-atom-suffix"><span class="feedback-marker-valid">&nbsp;</span></span></span>.</p>
</div>
<div class="lurch-atom" title="Good work!" data-metadata_type="&quot;proof&quot;" data-shell_title="Proof:" data-validation_result="valid">
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;Assume not(exists x.P(x))&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">Assume not </span><span class="ML__left-right" style="margin-top: -0.25em; height: 1em;"><span class="ML__small-delim ML__open">(</span><span class="ML__cmr">&exist;</span><span class="ML__mathit">x</span><span class="ML__cmr">.</span><span class="ML__mathit" style="margin-right: 0.14em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">x</span><span class="ML__small-delim ML__close">)</span></span><span class="ML__small-delim ML__close">)</span></span></span></span></span></span>. Now, for the first time, we will prove a universal claim in the standard way, by declaring an arbitrary variable and proving the claim about that new variable. The rule for universal introduction (Document &gt; Hide/show rules) requires us to do this in a subproof, as follows.</p>
<div class="lurch-atom" title="Good work!" data-metadata_type="&quot;subproof&quot;" data-shell_title="" data-validation_result="valid">
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;Let a&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">Let </span><span class="ML__mathit">a</span></span></span></span></span> be arbitrary. The previous sentence is the syntax used for declaring an arbitrary variable in Lurch. Lurch does not associate that kind of declaration with any rule of logic unless we tell it to, and the rules we've loaded into this document say that the way one proves a universal is by starting a subproof with that type of variable declaration. Our goal here is to achieve <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expositorymath&quot;" data-metadata_latex="&quot;\\neg P(a)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__ams">&not;</span><span class="ML__mathit" style="margin-right: 0.14em;">P</span><span class="ML__cmr">(</span><span class="ML__mathit">a</span><span class="ML__cmr">)</span></span></span></span></span>, but we must do so by contradiction.</p>
<div class="lurch-atom" title="Good work!" data-metadata_type="&quot;subproof&quot;" data-shell_title="" data-validation_result="valid">
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;Assume P(a)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">Assume </span><span class="ML__mathit" style="margin-right: 0.14em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">a</span><span class="ML__small-delim ML__close">)</span></span></span></span></span></span> towards a contradiction. We can conclude, then, that <span class="lurch-atom" title="Good work!" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;exists x.P(x)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__cmr">&exist;</span><span class="ML__mathit">x</span><span class="ML__cmr">.</span><span class="ML__mathit" style="margin-right: 0.14em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">x</span><span class="ML__small-delim ML__close">)</span></span></span></span></span><span class="lurch-atom-suffix"><span class="feedback-marker-valid">&nbsp;</span></span></span>, which contradicts the assumption at the top of the proof, and this subproof is already done.</p>
</div>
<p>So we have shown <span class="lurch-atom" title="Good work!" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;not P(a)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">not </span><span class="ML__mathit" style="margin-right: 0.14em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">a</span><span class="ML__small-delim ML__close">)</span></span></span></span></span><span class="lurch-atom-suffix"><span class="feedback-marker-valid">&nbsp;</span></span></span>, as desired.</p>
</div>
<p>The above subproof demonstrates that <span class="lurch-atom" title="Good work!" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;forall x.not P(x)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__cmr">&forall;</span><span class="ML__mathit">x</span><span class="ML__cmr">.</span><span class="ML__text">not </span><span class="ML__mathit" style="margin-right: 0.14em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">x</span><span class="ML__small-delim ML__close">)</span></span></span></span></span><span class="lurch-atom-suffix"><span class="feedback-marker-valid">&nbsp;</span></span></span>, and our proof is complete.</p>
</div>
<p>&nbsp;</p>
<div class="lurch-atom" title="Good work!" data-metadata_type="&quot;theorem&quot;" data-shell_title="Theorem:" data-validation_result="valid">
<p>De Morgan's Law, Part 4 of 4: <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;If not(forall x.P(x))&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">If not </span><span class="ML__left-right" style="margin-top: -0.25em; height: 1em;"><span class="ML__small-delim ML__open">(</span><span class="ML__cmr">&forall;</span><span class="ML__mathit">x</span><span class="ML__cmr">.</span><span class="ML__mathit" style="margin-right: 0.14em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">x</span><span class="ML__small-delim ML__close">)</span></span><span class="ML__small-delim ML__close">)</span></span></span></span></span></span> then <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;exists x.not P(x)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__cmr">&exist;</span><span class="ML__mathit">x</span><span class="ML__cmr">.</span><span class="ML__text">not </span><span class="ML__mathit" style="margin-right: 0.14em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">x</span><span class="ML__small-delim ML__close">)</span></span></span></span></span><span class="lurch-atom-suffix"><span class="feedback-marker-valid">&nbsp;</span></span></span>.</p>
</div>
<div class="lurch-atom" title="Good work!" data-metadata_type="&quot;proof&quot;" data-shell_title="Proof:" data-validation_result="valid">
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;Assume not(forall x.P(x))&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">Assume not </span><span class="ML__left-right" style="margin-top: -0.25em; height: 1em;"><span class="ML__small-delim ML__open">(</span><span class="ML__cmr">&forall;</span><span class="ML__mathit">x</span><span class="ML__cmr">.</span><span class="ML__mathit" style="margin-right: 0.14em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">x</span><span class="ML__small-delim ML__close">)</span></span><span class="ML__small-delim ML__close">)</span></span></span></span></span></span>. Since we do not have a witness to <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expositorymath&quot;" data-metadata_latex="&quot;\\neg P(x)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__ams">&not;</span><span class="ML__mathit" style="margin-right: 0.14em;">P</span><span class="ML__cmr">(</span><span class="ML__mathit">x</span><span class="ML__cmr">)</span></span></span></span></span>, we will need to prove the desired result by contradiction.</p>
<div class="lurch-atom" title="Good work!" data-metadata_type="&quot;subproof&quot;" data-shell_title="" data-validation_result="valid">
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;Assume not(exists x.not P(x))&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">Assume not </span><span class="ML__left-right" style="margin-top: -0.25em; height: 1em;"><span class="ML__small-delim ML__open">(</span><span class="ML__cmr">&exist;</span><span class="ML__mathit">x</span><span class="ML__cmr">.</span><span class="ML__text">not </span><span class="ML__mathit" style="margin-right: 0.14em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">x</span><span class="ML__small-delim ML__close">)</span></span><span class="ML__small-delim ML__close">)</span></span></span></span></span></span> towards a contradiction.</p>
<div class="lurch-atom" title="Good work!" data-metadata_type="&quot;subproof&quot;" data-shell_title="" data-validation_result="valid">
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;Let a&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">Let </span><span class="ML__mathit">a</span></span></span></span></span> be arbitrary. We aim to show that <span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expositorymath&quot;" data-metadata_latex="&quot;P(a)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit" style="margin-right: 0.14em;">P</span><span class="ML__cmr">(</span><span class="ML__mathit">a</span><span class="ML__cmr">)</span></span></span></span></span> holds, so that we can generalize and obtain the contradiction sought above.</p>
<div class="lurch-atom" title="Good work!" data-metadata_type="&quot;subproof&quot;" data-shell_title="" data-validation_result="valid">
<p><span class="lurch-atom" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;Assume not P(a)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__text">Assume not </span><span class="ML__mathit" style="margin-right: 0.14em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">a</span><span class="ML__small-delim ML__close">)</span></span></span></span></span></span>, also towards a contradiction. (Yes, nested indirect proofs!)</p>
<p>Then we can conclude <span class="lurch-atom" title="Good work!" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;exists x.not P(x)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__cmr">&exist;</span><span class="ML__mathit">x</span><span class="ML__cmr">.</span><span class="ML__text">not </span><span class="ML__mathit" style="margin-right: 0.14em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">x</span><span class="ML__small-delim ML__close">)</span></span></span></span></span><span class="lurch-atom-suffix"><span class="feedback-marker-valid">&nbsp;</span></span></span>, which contradicts the second assumption of this proof.</p>
</div>
<p>By the above subproof, we've shown <span class="lurch-atom" title="Good work!" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;P(a)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__mathit" style="margin-right: 0.14em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">a</span><span class="ML__small-delim ML__close">)</span></span></span></span></span><span class="lurch-atom-suffix"><span class="feedback-marker-valid">&nbsp;</span></span></span>, which was our goal for this subproof.</p>
</div>
<p>We therefore have <span class="lurch-atom" title="Good work!" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;forall x.P(x)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__cmr">&forall;</span><span class="ML__mathit">x</span><span class="ML__cmr">.</span><span class="ML__mathit" style="margin-right: 0.14em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">x</span><span class="ML__small-delim ML__close">)</span></span></span></span></span><span class="lurch-atom-suffix"><span class="feedback-marker-valid">&nbsp;</span></span></span>, which contradicts the first assumption in the proof. This achieves the first contradiction we were seeking.</p>
</div>
<p>So we have <span class="lurch-atom" title="Good work!" contenteditable="false" data-metadata_type="&quot;expression&quot;" data-metadata_lurch-notation="&quot;exists x.not P(x)&quot;"><span class="lurch-atom-body"><span class="ML__latex"><span class="ML__base"><span class="ML__cmr">&exist;</span><span class="ML__mathit">x</span><span class="ML__cmr">.</span><span class="ML__text">not </span><span class="ML__mathit" style="margin-right: 0.14em;">P</span><span class="ML__left-right" style="margin-top: 0em; height: 0.43056em;"><span class="ML__small-delim ML__open">(</span><span class="ML__mathit">x</span><span class="ML__small-delim ML__close">)</span></span></span></span></span><span class="lurch-atom-suffix"><span class="feedback-marker-valid">&nbsp;</span></span></span>, as desired.</p>
</div>
<p>&nbsp;</p>
<h2>Yes, but what about actual mathematics?</h2>
<p>Propositional and predicate logic are great, but we'd like to prove some actual mathematical content. Check out subsequent pages in this same tutorial series to do so!</p></div>
        